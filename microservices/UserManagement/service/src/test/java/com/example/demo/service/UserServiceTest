package com.example.demo.service;

import com.example.demo.model.User;
import com.example.demo.repository.UserRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class UserServiceTest {

    @Mock
    private UserRepository userRepository;

    @Mock
    private PasswordEncoder passwordEncoder;

    @Mock
    private TokenService tokenService;

    @InjectMocks
    private UserService userService;

    @Test
    void registerUser_ShouldSucceed_WhenEmailIsNew() {
        // ARRANGE (Préparation)
        User newUser = new User();
        newUser.setEmail("test@test.com");
        newUser.setPassword("rawPassword");
        newUser.setUsername("TestUser");

        // On dit : "Si on cherche cet email, on ne trouve rien (Optional.empty)"
        when(userRepository.findByEmail("test@test.com")).thenReturn(Optional.empty());
        
        // On dit : "Si on encode le mot de passe, retourne 'encoded123'"
        when(passwordEncoder.encode("rawPassword")).thenReturn("encoded123");
        
        // On dit : "Quand on sauvegarde, retourne l'utilisateur tel quel"
        when(userRepository.save(any(User.class))).thenAnswer(i -> i.getArguments()[0]);

        // ACT (Action)
        User result = userService.registerUser(newUser);

        // ASSERT (Vérification)
        assertNotNull(result);
        assertEquals("encoded123", result.getPassword()); // Vérifie que le mdp est bien encodé
        verify(userRepository, times(1)).save(any(User.class)); // Vérifie qu'on a bien appelé save()
    }

    @Test
    void registerUser_ShouldFail_WhenEmailAlreadyExists() {
        // ARRANGE
        User existingUser = new User();
        existingUser.setEmail("doublon@test.com");

        // On simule que l'email existe déjà en base
        when(userRepository.findByEmail("doublon@test.com")).thenReturn(Optional.of(new User()));

        // ACT & ASSERT
        // On s'attend à une exception
        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {
            userService.registerUser(existingUser);
        });

        assertEquals("Email déjà utilisé", exception.getMessage());
        verify(userRepository, never()).save(any()); // On ne doit JAMAIS sauvegarder si erreur
    }

    // --- TESTS LOGIN ---

    @Test
    void login_ShouldReturnToken_WhenCredentialsAreValid() {
        // ARRANGE
        String email = "valid@test.com";
        String rawPwd = "password123";
        String encodedPwd = "encodedPassword123";
        String expectedToken = "fake-jwt-token";

        User dbUser = new User();
        dbUser.setEmail(email);
        dbUser.setPassword(encodedPwd);

        // Simulations
        when(userRepository.findByEmail(email)).thenReturn(Optional.of(dbUser));
        when(passwordEncoder.matches(rawPwd, encodedPwd)).thenReturn(true); // Le mot de passe correspond
        when(tokenService.createLoginToken(dbUser)).thenReturn(expectedToken);

        // ACT
        String token = userService.login(email, rawPwd);

        // ASSERT
        assertEquals(expectedToken, token);
    }

    @Test
    void login_ShouldFail_WhenPasswordIsWrong() {
        // ARRANGE
        String email = "valid@test.com";
        User dbUser = new User();
        dbUser.setEmail(email);
        dbUser.setPassword("encodedCorrectPwd");

        when(userRepository.findByEmail(email)).thenReturn(Optional.of(dbUser));
        when(passwordEncoder.matches("wrongPwd", "encodedCorrectPwd")).thenReturn(false); // Le mot de passe ne correspond PAS

        // ACT & ASSERT
        RuntimeException ex = assertThrows(RuntimeException.class, () -> {
            userService.login(email, "wrongPwd");
        });

        assertEquals("Email ou mot de passe incorrect !", ex.getMessage());
    }

    @Test
    void login_ShouldFail_WhenUserNotFound() {
        // ARRANGE
        when(userRepository.findByEmail("unknown@test.com")).thenReturn(Optional.empty());

        // ACT & ASSERT
        assertThrows(RuntimeException.class, () -> {
            userService.login("unknown@test.com", "anyPwd");
        });
    }

    // --- TESTS VALIDATION TOKEN ---

    @Test
    void getUserIdFromToken_ShouldReturnId_WhenTokenValid() {
        // ARRANGE
        String token = "valid_token";
        Long expectedId = 42L;

        when(tokenService.validate(token, "LOGIN")).thenReturn(expectedId);

        // ACT
        Long resultId = userService.getUserIdFromToken(token);

        // ASSERT
        assertEquals(expectedId, resultId);
    }

    @Test
    void getUserIdFromToken_ShouldThrowException_WhenTokenInvalid() {
     
        String token = "invalid_token";
        when(tokenService.validate(token, "LOGIN")).thenReturn(null); 

        assertThrows(RuntimeException.class, () -> {
            userService.getUserIdFromToken(token);
        });
    }
}